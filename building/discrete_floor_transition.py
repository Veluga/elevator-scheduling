import settings as s
from .building import Building, Call, Elevator, ElevatorState, Passenger
from random import randint
import numpy as np

class DiscreteFloorTransition(Building):
    """Concrete building implementation that represents floor transitions as discrete jumps between them."""
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.reset()

    def call(self, call_floor, destination_floor):
        """Store information about call generated by caller."""
        passenger = Passenger()
        self.passengers[passenger.id] = passenger
        if call_floor < destination_floor:
            self.up_calls[call_floor].add((destination_floor, passenger.id))
        else:
            self.down_calls[call_floor].add((destination_floor, passenger.id))

    def _remove_passenger_ids(self, calls_dict):
        filtered = {f: set() for f in calls_dict}
        for floor in calls_dict:
            for dest, _ in calls_dict[floor]:
                filtered[floor].add(dest)
        return filtered

    def sample_state(self):
        """The building state can be sampled as both a numpy vector and a Python dictionary.
        Different agents may use either of these to construct their own representations of the state or consume them as is.
        """
        np_up_calls = np.array([[len(s) > 0 for f, s in self.up_calls.items()]], dtype=int)
        np_down_calls = np.array([[len(s) > 0 for f, s in self.down_calls.items()]], dtype=int)
        np_state_vector = np.append(np_up_calls, np_down_calls)
        for e in self.elevators:
            np_state_vector = np.append(np_state_vector, [e.cur_floor])
            np_state_vector = np.append(np_state_vector, [s == e.state for s in range(min(ElevatorState).value, max(ElevatorState).value+1)])
            np_state_vector = np.append(np_state_vector, [f in e.buttons_pressed for f in range(self.floors)])
        return np_state_vector, {
            'up_calls': self._remove_passenger_ids(self.up_calls),
            'down_calls': self._remove_passenger_ids(self.down_calls),
            'elevators': self.elevators
        }

    def perform_action(self, actions):
        """An agent will produce one action per elevator to be executed by the building.
        This function is responsible for updating the building state as a result of executing the desired actions.
        """
        def update_position(elevator, action):
            if action == ElevatorState.ASCENDING:
                # An elevator cannot ascend in the top floor
                if elevator.cur_floor != self.floors-1:
                    elevator.cur_floor += 1
                    elevator.direction = ElevatorState.ASCENDING
            elif action == ElevatorState.DESCENDING:
                # An elevator cannot descend from the ground floor
                if elevator.cur_floor != 0:
                    elevator.cur_floor -= 1
                    elevator.direction = ElevatorState.DESCENDING

        # Increase waitin/system time of passengers in system
        for passenger in self.passengers.values():
            passenger.wait_tick()

        # Delegate call generating to caller
        from_, to = self.caller.generate_call()
        if from_ is not None and to is not None:
            self.call(from_, to)

        # Rewards are stored on a per-elevator basis
        rewards = []
        for elevator, action in zip(self.elevators, actions):
            # Default reward is zero
            rewards.append(0)
            # Move elevator according to action
            update_position(elevator, action)
            elevator.state = action
            
            # Only stopped elevators can have passengers boarding or disembarking
            if elevator.state != ElevatorState.STOPPED:
                continue
            
            # Check whether ascending passengers boarding
            if len(self.up_calls[elevator.cur_floor]) > 0:
                for destination, passenger_id in self.up_calls[elevator.cur_floor]:
                    elevator.buttons_pressed.add(destination)
                    elevator.passengers.add((destination, passenger_id))
                    self.passengers[passenger_id].enter_elevator()
                self.up_calls[elevator.cur_floor] = set()

            # Check whether descending passengers boarding
            if len(self.down_calls[elevator.cur_floor]) > 0:
                for destination, passenger_id in self.down_calls[elevator.cur_floor]:
                    elevator.buttons_pressed.add(destination)
                    elevator.passengers.add((destination, passenger_id))
                    self.passengers[passenger_id].enter_elevator()
                self.down_calls[elevator.cur_floor] = set()

            # Check whether passengers disembarking
            if elevator.cur_floor in elevator.buttons_pressed:
                rewards[-1] += s.REWARD_DELIVERED_PASSENGER
                elevator.buttons_pressed.remove(elevator.cur_floor)
                served_passengers = []
                for destination, passenger_id in elevator.passengers:
                    if elevator.cur_floor == destination:
                        self.passengers[passenger_id].mark_served()
                        served_passengers.append((destination, passenger_id))
                for served in served_passengers:
                    elevator.passengers.remove(served)
        return rewards
    
    def _reset(self):
        # Reset building state (called by reset function in parent class)
        self.up_calls = {floor_num: set() for floor_num in range(self.floors)}
        self.down_calls = {floor_num: set() for floor_num in range(self.floors)}
        self.passengers = {}